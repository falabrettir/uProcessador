library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity banco_9_regs is 
    port (
        clk          : in  std_logic;
        rst          : in  std_logic;
        wr_en        : in  std_logic;
        addr_wr      : in  std_logic_vector(3 downto 0);
        ra1          : in  std_logic_vector(3 downto 0);
        ra2          : in  std_logic_vector(3 downto 0);
        data_wr      : in  unsigned(15 downto 0);
        data_r1      : out unsigned(15 downto 0);
        data_r2      : out unsigned(15 downto 0)
    );
end entity banco_9_regs;

architecture a_banco_9_regs of banco_9_regs is
    component reg16bits
        port (
            clk     : in  std_logic;
            rst     : in  std_logic;
            wr_en   : in  std_logic;
            data_in : in  unsigned(15 downto 0);
            data_out: out unsigned(15 downto 0)
        );
    end component;
    
    -- Sinais: reg0 a reg8 (9 registradores)
    signal reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7, reg8 : unsigned(15 downto 0);
    signal wr_en0, wr_en1, wr_en2, wr_en3, wr_en4, wr_en5, wr_en6, wr_en7, wr_en8 : std_logic;

begin
    -- Decodificação do endereço de escrita
    wr_en0 <= wr_en when addr_wr = "0000" else '0';
    wr_en1 <= wr_en when addr_wr = "0001" else '0';
    wr_en2 <= wr_en when addr_wr = "0010" else '0';
    wr_en3 <= wr_en when addr_wr = "0011" else '0';
    wr_en4 <= wr_en when addr_wr = "0100" else '0';
    wr_en5 <= wr_en when addr_wr = "0101" else '0';
    wr_en6 <= wr_en when addr_wr = "0110" else '0';
    wr_en7 <= wr_en when addr_wr = "0111" else '0';
    wr_en8 <= wr_en when addr_wr = "1000" else '0';

    -- Portmap dos registradores
    port_map_reg0: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en0, data_in => data_wr, data_out => reg0);
    port_map_reg1: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en1, data_in => data_wr, data_out => reg1);
    port_map_reg2: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en2, data_in => data_wr, data_out => reg2);
    port_map_reg3: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en3, data_in => data_wr, data_out => reg3);
    port_map_reg4: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en4, data_in => data_wr, data_out => reg4);
    port_map_reg5: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en5, data_in => data_wr, data_out => reg5);
    port_map_reg6: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en6, data_in => data_wr, data_out => reg6);
    port_map_reg7: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en7, data_in => data_wr, data_out => reg7);
    port_map_reg8: reg16bits port map (clk=>clk, rst=>rst, wr_en => wr_en8, data_in => data_wr, data_out => reg8);

    -- Multiplexadores para leitura
    with ra1 select
        data_r1 <= reg0 when "0000",
                   reg1 when "0001",
                   reg2 when "0010",
                   reg3 when "0011",
                   reg4 when "0100",
                   reg5 when "0101",
                   reg6 when "0110",
                   reg7 when "0111",
                   reg8 when "1000",
                   (others => '0') when others;
                   
    with ra2 select
        data_r2 <= reg0 when "0000",
                   reg1 when "0001",
                   reg2 when "0010",
                   reg3 when "0011",
                   reg4 when "0100",
                   reg5 when "0101",
                   reg6 when "0110",
                   reg7 when "0111",
                   reg8 when "1000",
                   (others => '0') when others;
end architecture a_banco_9_regs;library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
-- registrador de instrucoes
entity ir is 
    port (
        clk     : in  std_logic;
        rst     : in  std_logic;
        wr_en   : in  std_logic;
        ir_in   : in  unsigned(16 downto 0); -- próximo
        ir_out  : out unsigned(16 downto 0)  --  atual 
    );
end entity ir; 

architecture a_ir of ir is
    signal ir_reg: unsigned(16 downto 0) := (others => '0');
begin
    -- processo do reg
    process(clk, rst)
    begin
        if rst = '1' then
            ir_reg <= (others => '0');
        elsif wr_en = '1' and rising_edge(clk) then
            -- valor de ir_in
            ir_reg <= ir_in;
        end if;
    end process;

    -- valor armazenado no reg
    ir_out <= ir_reg;
    
end architecture a_ir;
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
entity maq_estados is
   port( clk,rst: in std_logic;
         estado: out unsigned(1 downto 0)
   );
end entity;
architecture a_maq_estados of maq_estados is
   signal estado_s: unsigned(1 downto 0);
begin
   process(clk,rst)
   begin
      if rst='1' then
         estado_s <= "00";
      elsif rising_edge(clk) then
         if estado_s="10" then        -- se agora esta em 2
            estado_s <= "00";         -- o prox vai voltar ao zero
         else
            estado_s <= estado_s+1;   -- senao avanca
         end if;
      end if;
   end process;
   estado <= estado_s;
end architecture;
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity pc is 
    port (
        clk     : in  std_logic;
        rst     : in  std_logic;
        wr_en   : in  std_logic;
        pc_in   : in  unsigned(16 downto 0); -- próximo
        pc_out  : out unsigned(16 downto 0)  --  atual 
    );
end entity pc; 

architecture a_pc of pc is
    signal pc_reg: unsigned(16 downto 0) := (others => '0');
begin
    -- processo do reg
    process(clk, rst)
    begin
        if rst = '1' then
            pc_reg <= (others => '0');
        elsif wr_en = '1' and rising_edge(clk) then
            -- valor de pc_in
            pc_reg <= pc_in;
        end if;
    end process;

    -- valor armazenado no reg
    pc_out <= pc_reg;
    
end architecture a_pc;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity processador is
  port(
      clk: in std_logic;
      rst: in std_logic
  );
end entity processador;

architecture a_processador of processador is 

    -- === COMPONENTES ===
    component pc is
        port (
            clk     : in  std_logic;
            rst     : in  std_logic;
            wr_en   : in  std_logic;
            pc_in   : in  unsigned(16 downto 0);
            pc_out  : out unsigned(16 downto 0)
        );
    end component;
    
    component rom is
        port ( 
              clk      : in std_logic;
              endereco : in unsigned(6 downto 0);
              dado     : out unsigned(16 downto 0) 
        );
    end component;

    component ir is
        port (
            clk     : in  std_logic;
            rst     : in  std_logic;
            wr_en   : in  std_logic;
            ir_in   : in  unsigned(16 downto 0);
            ir_out  : out unsigned(16 downto 0)
        );
    end component;

    component ula is
        port (
           a: in unsigned (15 downto 0);
           b: in unsigned (15 downto 0);
           chave: in std_logic_vector (1 downto 0);
           u_output: out unsigned (15 downto 0);
           f_zero: out std_logic;
           f_carry: out std_logic
        );
    end component;

    component banco_9_regs is  
        port (
            clk          : in  std_logic;
            rst          : in  std_logic;
            wr_en        : in  std_logic;
            addr_wr      : in  std_logic_vector(3 downto 0);
            ra1          : in  std_logic_vector(3 downto 0);
            ra2          : in  std_logic_vector(3 downto 0);
            data_wr      : in  unsigned(15 downto 0);
            data_r1      : out unsigned(15 downto 0);
            data_r2      : out unsigned(15 downto 0)
        );
    end component;

    component uc is
        port (
            clk           : in  std_logic;                      
            rst           : in  std_logic;             
            opcode_in     : in  unsigned(3 downto 0);
            pc_atual_in   : in  unsigned(16 downto 0);
            const_5bit_in : in  unsigned(4 downto 0);
            const_13bit_in: in  unsigned(12 downto 0);
            reg_src1_in   : in  std_logic_vector(3 downto 0);
            flag_z_in     : in  std_logic;
            flag_c_in     : in  std_logic;
            pc_wr_en_out  : out std_logic;                      
            ir_wr_en_out  : out std_logic;                      
            reg_wr_en_out : out std_logic;
            flags_wr_en_out: out std_logic;
            ula_chave_out : out std_logic_vector(1 downto 0);   
            sel_mux_ula_b_out : out std_logic;                 
            sel_mux_reg_wr_out: out std_logic_vector(1 downto 0);                
            ram_wr_en_out : out std_logic;                      
            pc_in_out     : out unsigned(16 downto 0)           
        );
    end component uc;

    component registrador_flags is 
        port (
            clk     : in  std_logic;
            rst     : in  std_logic;
            wr_en   : in  std_logic;
            data_zero       : in  std_logic;
            data_carry : in std_logic;
            zero_out: out std_logic;
            carry_out: out std_logic
        );
    end component;

    component ram is
       port( 
             clk      : in std_logic;
             endereco : in unsigned(6 downto 0); -- Endereço de 7 bits [cite: 920, 924, 1429]
             wr_en    : in std_logic;            -- Habilitação de escrita [cite: 921, 924, 1429]
             dado_in  : in unsigned(15 downto 0); -- Dado para escrever [cite: 920, 923, 1429]
             dado_out : out unsigned(15 downto 0)  -- Dado lido da RAM [cite: 924, 926, 1429]
       );
    end component;

    -- === SINAIS ===
    signal s_pc_out      : unsigned(16 downto 0);
    signal s_rom_out     : unsigned(16 downto 0);
    signal s_ir_out      : unsigned(16 downto 0);
    signal s_next_pc     : unsigned(16 downto 0);
    signal s_ram_data_out : unsigned(15 downto 0); -- Saída de dados da RAM
    signal s_ram_wr_en    : std_logic;             -- Habilitação de escrita da RAM


    -- instrucao fatiada
    signal s_opcode      : unsigned(3 downto 0);
    signal s_reg_dest    : std_logic_vector(3 downto 0);
    signal s_reg_src1    : std_logic_vector(3 downto 0);
    signal s_reg_src2    : std_logic_vector(3 downto 0);
    signal s_const_5bit  : unsigned(4 downto 0);
    signal s_const_13bit : unsigned(12 downto 0);

    -- dados
    signal s_dados_r1    : unsigned(15 downto 0);
    signal s_dados_r2    : unsigned(15 downto 0); 
    signal s_ula_out     : unsigned(15 downto 0);
    signal s_const_16bit : unsigned(15 downto 0); 
    signal s_mux_ula_b   : unsigned(15 downto 0);
    signal s_mux_reg_wr  : unsigned(15 downto 0);

    -- controle
    signal s_pc_wr_en    : std_logic;
    signal s_ir_wr_en    : std_logic; 
    signal s_reg_wr_en   : std_logic;
    signal s_ula_chave   : std_logic_vector(1 downto 0);
    signal s_sel_mux_ula_b: std_logic;
    signal s_sel_mux_reg_wr: std_logic_vector(1 downto 0); 
    
    signal s_flags_wr_en : std_logic; -- UC -> wr_en do Reg. Flags
    signal s_flag_z_out  : std_logic; -- Reg. Flags -> UC
    signal s_flag_c_out  : std_logic; -- Reg. Flags -> UC

    -- Saídas da ULA para as Flags
    signal s_f_zero      : std_logic;
    signal s_f_carry     : std_logic;

begin 
 
-- fatiada na instrucao
  s_opcode      <= s_ir_out(16 downto 13);
  s_reg_dest    <= std_logic_vector(s_ir_out(12 downto 9));

  s_reg_src1    <= std_logic_vector(s_ir_out(8 downto 5)) when s_opcode = "1000" or s_opcode = "1001" else
                   std_logic_vector(s_ir_out(12 downto 9)); --tipo R

  s_reg_src2    <= std_logic_vector(s_ir_out(8 downto 5));
  s_const_5bit  <= s_ir_out(4 downto 0);
  s_const_13bit <= s_ir_out(12 downto 0);

  s_const_16bit <= unsigned(resize(unsigned(s_const_5bit), 16)); --por causa dos negativos em cpl 2 

  s_mux_ula_b <= s_const_16bit when s_sel_mux_ula_b = '1' else 
                 s_dados_r2;

  -- LÓGICA DO MUX  
  -- O sinal seleciona a fonte:
  -- "00" = Resultado da ULA (para ADD, SUB, MOV, etc.)
  -- "01" = Constante (para LD)
  -- "10" = Dado da RAM (para LW)
  s_mux_reg_wr <= s_ula_out          when s_sel_mux_reg_wr = "00" else
                  s_const_16bit      when s_sel_mux_reg_wr = "01" else
                  s_ram_data_out     when s_sel_mux_reg_wr = "10" else
                  (others => '0'); -- valor padrão 

  inst_pc: pc
        port map (
            clk     => clk,
            rst     => rst,
            wr_en   => s_pc_wr_en,
            pc_in   => s_next_pc,
            pc_out  => s_pc_out
        );

  inst_rom: rom
        port map (
            clk      => clk,
            endereco => s_pc_out(6 downto 0),
            dado     => s_rom_out
        );

  inst_ir: ir
        port map (
            clk     => clk,
            rst     => rst,
            wr_en   => s_ir_wr_en,
            ir_in   => s_rom_out,
            ir_out  => s_ir_out
        );

  inst_banco: banco_9_regs
        port map (
            clk     => clk,
            rst     => rst,
            wr_en   => s_reg_wr_en,
            addr_wr => s_reg_dest,
            ra1     => s_reg_src1,
            ra2     => s_reg_src2,
            data_wr => s_mux_reg_wr,
            data_r1 => s_dados_r1,
            data_r2 => s_dados_r2
        );

  inst_ula: ula
        port map (
            a        => s_dados_r1,
            b        => s_mux_ula_b,
            chave    => s_ula_chave,
            u_output => s_ula_out,    
            f_zero   => s_f_zero,     
            f_carry  => s_f_carry     
        );

  inst_flags: registrador_flags
        port map(
             clk        => clk,
             rst        => rst, 
             wr_en      => s_flags_wr_en,
             data_zero  => s_f_zero,
             data_carry => s_f_carry,
             zero_out   => s_flag_z_out,
             carry_out  => s_flag_c_out
        );

  inst_uc: uc
        port map (
            clk                => clk,
            rst                => rst,
            opcode_in          => s_opcode,
            pc_atual_in        => s_pc_out,
            const_5bit_in      => s_const_5bit,
            const_13bit_in     => s_const_13bit,
            reg_src1_in        => s_reg_src1,
            flag_z_in          => s_flag_z_out,
            flag_c_in          => s_flag_c_out,
            pc_wr_en_out       => s_pc_wr_en,
            ir_wr_en_out       => s_ir_wr_en,
            reg_wr_en_out      => s_reg_wr_en,
            flags_wr_en_out    => s_flags_wr_en,
            ula_chave_out      => s_ula_chave,
            sel_mux_ula_b_out  => s_sel_mux_ula_b, 
            sel_mux_reg_wr_out => s_sel_mux_reg_wr,
            ram_wr_en_out      => s_ram_wr_en, -- novo sinal pra ram
            pc_in_out          => s_next_pc
        );
    inst_ram: ram
        port map (
            clk      => clk,
            -- O endereço vem do registrador lido na porta 1 
            -- Usamos os 7 bits inferiores do dado lido do banco 
            endereco => s_dados_r1(6 downto 0), 
            
            -- O dado a ser escrito na RAM vem do registrador lido na porta 2 (ex: sw r2, (r1))
            dado_in  => s_dados_r2,
            
            -- O 'write enable' é controlado pela UC
            wr_en    => s_ram_wr_en,
            
            -- A saída da RAM vai para o MUX de escrita do registrador
            dado_out => s_ram_data_out
        );

end architecture a_processador;
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
------------------------------------------------------------------------
entity ram is
   port( 
         clk      : in std_logic;
         endereco : in unsigned(6 downto 0);
         wr_en    : in std_logic;
         dado_in  : in unsigned(15 downto 0);
         dado_out : out unsigned(15 downto 0) 
   );
end entity;
------------------------------------------------------------------------
architecture a_ram of ram is
   type mem is array (0 to 127) of unsigned(15 downto 0);
   signal conteudo_ram : mem;
begin
   process(clk,wr_en)
   begin
      if rising_edge(clk) then
         if wr_en='1' then
            conteudo_ram(to_integer(endereco)) <= dado_in;
         end if;
      end if;
   end process;
   dado_out <= conteudo_ram(to_integer(endereco));
end architecture;library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity reg16bits is 
    port (
        clk     : in  std_logic;
        rst     : in  std_logic;
        wr_en   : in  std_logic;
        data_in       : in  unsigned(15 downto 0);
        data_out      : out unsigned(15 downto 0)
    );
end entity reg16bits; 

    architecture a_reg16bits of reg16bits is
        signal reg : unsigned(15 downto 0);
    begin
        process(clk, rst, wr_en)
        begin
            if rst = '1' then
                reg <= (others => '0');
            elsif wr_en = '1' then
                if rising_edge(clk) then
                    reg <= data_in;
                end if;
            end if;
        end process;
        data_out <= reg;
    end a_reg16bits;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity registrador_flags is 
    port (
        clk     : in  std_logic;
        rst     : in  std_logic;
        wr_en   : in  std_logic;
        data_zero       : in  std_logic;
        data_carry : in std_logic;

        zero_out: out std_logic;
        carry_out: out std_logic
    );
end entity registrador_flags; 

architecture a_registrador_flags of registrador_flags is
    signal s_zero_reg  : std_logic;
    signal s_carry_reg : std_logic;
begin
    
    process(clk, rst)
    begin
        if rst = '1' then
            s_zero_reg  <= '0';
            s_carry_reg <= '0';
        elsif rising_edge(clk) then
            if wr_en = '1' then
                s_zero_reg  <= data_zero;
                s_carry_reg <= data_carry;
            end if;
        end if;
    end process;

    zero_out  <= s_zero_reg;
    carry_out <= s_carry_reg;

end architecture a_registrador_flags;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity rom is
   port( clk      : in std_logic;
         endereco : in unsigned(6 downto 0);
         dado     : out unsigned(16 downto 0)
   );
end entity;

architecture a_rom of rom is

   type mem is array (0 to 127) of unsigned(16 downto 0);
   -- ISA:
   -- NOP:  0000_XXXX_XXXX_XXXX_X
   -- ADD:  0001_DEST_SRC1_SRC2_X
   -- SUB:  0010_DEST_SRC1_SRC2_X
   -- ADDI: 1000_DEST_SRC1_IMM5   (Usado para LD R, Imm e MOV R, R)
   -- SUBI: 1001_DEST_SRC1_IMM5
   -- JMP:  1111_ADDR13
   -- CMPR: 0011_XXXX_SRC1_SRC2_0 
   -- BLO:  1101_ADDR13 
   -- BNE:  1100_ADDR13
   
-- ADDI R3, R0, 0  "1000_0011_0000_00000"--
-- ADDI R4, R0, 0  "1000_0100_0000_00000"--
-- ADD R4, R3, R4  "0001_0100_0011_0100_0"--
-- ADDI R3, R3, 1  "1000_0011_0011_00001"--
-- ADDI R2, R0, 30 "1000_0010_0000_11110"
-- CMPR RX, R3, R2 "0011_0000_0011_0010_0"
-- BLO R3, -4      "1101_1111111111110" --VOLTA PRA INSTRUCAO "C"
-- ADD R5, R4, R0  "0001_0101_0100_0000_0"

-- A. Carrega R3 (o registrador 3) com o valor 0
-- B. Carrega R4 com 0
-- C. Soma R3 com R4 e guarda em R4
-- D. Soma 1 em R3
-- E. Se R3<30 salta para a instrução do passo C * 
-- F. Copia valor de R4 para R5
   constant conteudo_rom : mem := (
      -- ADDI R3, R0, 0
      -- Opcode=1000, Dest=R3(0011), Src1=R0(0000), Imm5=0(00000)
      0  => "10000011000000000",

      -- ADDI R4, R0, 0
      -- Opcode=1000, Dest=R4(0100), Src1=R0(0000), Imm5=0(00000)
      1  => "10000100000000000",

      -- ADD R4, R3
      -- Opcode=0001, DestSRC=R4(0100), Src2=R3(0011), X=0
      2  => "00010100001100000", 

      -- ADDI R3, R3, 1
      -- Opcode=1000, Dest=R3(0011), Src1=R3(0011), Imm5=1(00001)
      3  => "10000011001100001",

      -- ADDI R2, R0, 30
      -- Opcode=1000, Dest=R2(0010), Src1=R0(0000), Imm5=30(11110)
      4  => "10000010000011110",

      -- CMPR R0, R3, R2
      -- Opcode=0011, Dest=R0(0000), Src1=R3(0011), Src2=R2(0010), X=0
      5  => "00110011001000000",

      -- BLO R3, -4
      -- Opcode=1101, Addr13=-4(1111111111100)
      6  => "11011111111111011",
      -- ADD R5, R4
      -- Opcode=0001, DestSRC=R5(0101), Src1=R4(0100), X=0
      7 => "10000101010000000",

      8 => "11110000000001000",

      --NOP
      others => (others=>'0')
   );
begin
   process(clk)
   begin
      if(rising_edge(clk)) then
         dado <= conteudo_rom(to_integer(endereco));
      end if;
   end process;
end architecture a_rom;
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity uc is
    port (
        clk           : in  std_logic;                      
        rst           : in  std_logic;                      
    -- ir e pc
        opcode_in     : in  unsigned(3 downto 0);          -- opcode [16:13] 
        pc_atual_in   : in  unsigned(16 downto 0);          -- pc
        const_5bit_in : in  unsigned(4 downto 0);          -- constante [4:0] 
        const_13bit_in: in  unsigned(12 downto 0);         -- endereço [12:0] pro jump 
        reg_src1_in: in std_logic_vector (3 downto 0);
        flag_z_in : in std_logic; 
        flag_c_in: in std_logic;
--saidas
        pc_wr_en_out  : out std_logic;                      -- escrita no PC
        ir_wr_en_out  : out std_logic;                      -- escrita no IR
        reg_wr_en_out : out std_logic;                      -- escrita no banco
        ula_chave_out : out std_logic_vector(1 downto 0);   -- operação da ula
        sel_mux_ula_b_out : out std_logic;                  -- entrada B da ula
        sel_mux_reg_wr_out: out std_logic_vector(1 downto 0);-- dado a escrever no banco, 0 ula 1 banco 2 ram
        ram_wr_en_out : out std_logic;                      -- escrita na RAM
        flags_wr_en_out: out std_logic;
        pc_in_out     : out unsigned(16 downto 0)           -- próximo pc
    );
end entity uc;

architecture a_uc of uc is

  component maq_estados is
    port ( 
        clk,rst: in std_logic;
        estado: out unsigned(1 downto 0)
    );
  end component;

 signal s_pc_offset_ext : unsigned(16 downto 0); 
 signal s_estado_atual: unsigned(1 downto 0);

begin

state_instance: maq_estados
  port map (
          clk => clk,
          rst => rst,
          estado => s_estado_atual
    );

  s_pc_offset_ext <= unsigned(resize(signed(const_13bit_in), 17));

  ir_wr_en_out <= '1' when s_estado_atual = "01" else '0'; --fetch

  pc_wr_en_out <= '1' when s_estado_atual = "10" else '0'; --decode

pc_in_out <= ("0000" & const_13bit_in) when (s_estado_atual = "10" and opcode_in = "1111") else 
             (pc_atual_in + 1 + s_pc_offset_ext) when (s_estado_atual = "10" and opcode_in = "1100" and flag_z_in = '0') else 
             (pc_atual_in + 1 + s_pc_offset_ext) when (s_estado_atual = "10" and opcode_in = "1101" and flag_c_in = '1') else 
             (pc_atual_in + 1) when (s_estado_atual = "10") else 
             pc_atual_in;

  flags_wr_en_out <= '1' when (s_estado_atual = "10" and opcode_in = "0011") else 
                   '0';

  --controle do banco
  reg_wr_en_out <= '1' when (s_estado_atual = "10") and
                   (opcode_in = "0001" or --add 
                    opcode_in = "0010" or --sub 
                    opcode_in = "1000" or --addi
                    opcode_in = "1001" or --subi
                    opcode_in = "0111")   --lw 
                  else '0';
    
    --controle da ula 
ula_chave_out <= "00" when (s_estado_atual = "10") and (opcode_in = "0001" or opcode_in = "1000") else --add e addi 
                 "01" when (s_estado_atual = "10") and (opcode_in = "0010" or -- sub
                  opcode_in = "1001" or -- subi 
                  opcode_in = "0011") else 
                  "00"; -- nop, jump etc
                   
    --mux da ula
    sel_mux_ula_b_out <= '1' when (s_estado_atual = "10") and 
                         (opcode_in = "1000" or -- addi
                         opcode_in = "1001") -- subi
                       else '0'; --por padrao pega do registrador
    -- controle da ram
    ram_wr_en_out <= '1' when (s_estado_atual = "10" and opcode_in = "1011") -- sw
                       else '0';

    --mux do banco 
      sel_mux_reg_wr_out <= "01" when (s_estado_atual = "10" and -- Constante 
                                   opcode_in = "1000" and 
                                   reg_src1_in = "0000") else
                        "10" when (s_estado_atual = "10" and -- Dado da RAM (lw)
                                   opcode_in = "0111") else
                        "00"; -- Padrão: saida da ula

end architecture a_uc;
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ula is 
  port(

  a: in unsigned (15 downto 0);
  b: in unsigned (15 downto 0);
  chave: in std_logic_vector (1 downto 0);

  u_output: out unsigned (15 downto 0);
  f_zero: out std_logic; f_carry: out std_logic
      );
end entity;

architecture a_ula of ula is
  signal r_s_ext: unsigned (16 downto 0);
  signal r_s: unsigned (15 downto 0);
  signal r_sub: unsigned (15 downto 0);
  signal r_and: unsigned (15 downto 0);
  signal r_or: unsigned (15 downto 0);

  signal temp: unsigned(15 downto 0);
begin
  r_s_ext <= ('0' & a) + ('0' & b);
  r_s <= r_s_ext(15 downto 0);
  r_sub <= a - b;
  r_and<= a and b;
  r_or <= a or b;

  temp <= r_s when chave = "00" else
          r_sub when chave = "01" else
          r_and when chave = "10" else
          r_or when chave = "11" else
          (others => '0');
          
  f_zero <= '1' when temp = "0000000000000000" else '0';
  
  f_carry <= r_s_ext(16) when chave = "00" else
             '1' when chave = "01" and a < b else
             '0';

  u_output <= temp;

end architecture;
